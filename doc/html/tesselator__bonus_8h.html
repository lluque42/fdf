<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fdf: include/bonus/tesselator_bonus.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Fdf<span id="projectnumber">&#160;2024-07-25</span>
   </div>
   <div id="projectbrief">Fdf project for Campus 42</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_f357540ff39808677932645f69e050d2.html">bonus</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tesselator_bonus.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="fdf__bonus_8h_source.html">fdf_bonus.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lin__alg__bonus_8h_source.html">lin_alg_bonus.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for tesselator_bonus.h:</div>
<div class="dyncontent">
<div class="center"><img src="tesselator__bonus_8h__incl.png" border="0" usemap="#ainclude_2bonus_2tesselator__bonus_8h" alt=""/></div>
<map name="ainclude_2bonus_2tesselator__bonus_8h" id="ainclude_2bonus_2tesselator__bonus_8h">
<area shape="rect" title=" " alt="" coords="365,5,546,47"/>
<area shape="rect" title=" " alt="" coords="5,169,76,196"/>
<area shape="rect" href="fdf__bonus_8h.html" title=" " alt="" coords="406,95,505,121"/>
<area shape="rect" href="lin__alg__bonus_8h.html" title=" " alt="" coords="901,169,1023,196"/>
<area shape="rect" title=" " alt="" coords="260,244,339,271"/>
<area shape="rect" title=" " alt="" coords="151,169,210,196"/>
<area shape="rect" href="window__bonus_8h.html" title=" " alt="" coords="234,169,365,196"/>
<area shape="rect" href="drawing__bonus_8h.html" title=" " alt="" coords="389,169,521,196"/>
<area shape="rect" href="fdf__features__bonus_8h.html" title=" " alt="" coords="545,169,704,196"/>
<area shape="rect" href="main__utils__bonus_8h.html" title=" " alt="" coords="728,169,876,196"/>
<area shape="rect" title=" " alt="" coords="421,244,489,271"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="tesselator__bonus_8h__dep__incl.png" border="0" usemap="#ainclude_2bonus_2tesselator__bonus_8hdep" alt=""/></div>
<map name="ainclude_2bonus_2tesselator__bonus_8hdep" id="ainclude_2bonus_2tesselator__bonus_8hdep">
<area shape="rect" title=" " alt="" coords="409,5,591,47"/>
<area shape="rect" href="fdf__bonus_8h.html" title=" " alt="" coords="404,95,596,121"/>
<area shape="rect" href="drawing__bonus_8h.html" title=" " alt="" coords="5,169,173,211"/>
<area shape="rect" href="fdf__features__bonus_8h.html" title=" " alt="" coords="197,169,392,211"/>
<area shape="rect" href="lin__alg__bonus_8h.html" title=" " alt="" coords="607,169,766,211"/>
<area shape="rect" href="window__bonus_8h.html" title=" " alt="" coords="417,169,583,211"/>
</map>
</div>
</div>
<p><a href="tesselator__bonus_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__fdf__edge.html">s_fdf_edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for typedef <b>t_fdf_edge</b>.  <a href="structs__fdf__edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__fdf__nv.html">s_fdf_nv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for typedef <b>t_fdf_nv</b>.  <a href="structs__fdf__nv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__fdf__3drect.html">s_fdf_3drect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for typedef <b>t_ft_mx_3drect</b>.  <a href="structs__fdf__3drect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__fdf__plane.html">s_fdf_plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for typedef <b>t_fdf_plane</b>.  <a href="structs__fdf__plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__fdf__triangle.html">s_fdf_triangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for typedef <b>t_fdf_triangle</b>.  <a href="structs__fdf__triangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__fdf__object.html">s_fdf_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for typedef <b>t_fdf_object</b>.  <a href="structs__fdf__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a26ef95a8eff7e68f9f4cc37f458c9326"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a26ef95a8eff7e68f9f4cc37f458c9326">RADIUS_RATE</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a26ef95a8eff7e68f9f4cc37f458c9326"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af3c0e397419104bde80dd7464cc5266a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="tesselator__bonus_8h.html#a35dd9ea512bda830c7abbe9a8582cba6">e_tesselation_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#af3c0e397419104bde80dd7464cc5266a">t_tesselation_type</a></td></tr>
<tr class="separator:af3c0e397419104bde80dd7464cc5266a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997a884aebfbd35b8c746e1dabb7f3c4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__fdf__edge.html">s_fdf_edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a997a884aebfbd35b8c746e1dabb7f3c4">t_fdf_edge</a></td></tr>
<tr class="separator:a997a884aebfbd35b8c746e1dabb7f3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c00f492f251160c49cdf977ea1c6367"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__fdf__nv.html">s_fdf_nv</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a7c00f492f251160c49cdf977ea1c6367">t_fdf_nv</a></td></tr>
<tr class="separator:a7c00f492f251160c49cdf977ea1c6367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a91978956247bd2a59360803b13c7e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__fdf__3drect.html">s_fdf_3drect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a11a91978956247bd2a59360803b13c7e">t_fdf_3drect</a></td></tr>
<tr class="separator:a11a91978956247bd2a59360803b13c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67794afb8c91e77cdbeb21389edf5eda"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__fdf__plane.html">s_fdf_plane</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a67794afb8c91e77cdbeb21389edf5eda">t_fdf_plane</a></td></tr>
<tr class="separator:a67794afb8c91e77cdbeb21389edf5eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b90bf626ce47bf7731feaed57fe4b2c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__fdf__triangle.html">s_fdf_triangle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a7b90bf626ce47bf7731feaed57fe4b2c">t_fdf_triangle</a></td></tr>
<tr class="separator:a7b90bf626ce47bf7731feaed57fe4b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ed0c56ef8fb06d8186b340101a1d7f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__fdf__object.html">s_fdf_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a></td></tr>
<tr class="separator:ac4ed0c56ef8fb06d8186b340101a1d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a35dd9ea512bda830c7abbe9a8582cba6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a35dd9ea512bda830c7abbe9a8582cba6">e_tesselation_type</a> { <a class="el" href="tesselator__bonus_8h.html#a35dd9ea512bda830c7abbe9a8582cba6ae6396c2dda7d51b8e4f6f316752bcbb7">PLANE_TESSELATION</a>
, <a class="el" href="tesselator__bonus_8h.html#a35dd9ea512bda830c7abbe9a8582cba6ab38056c07f064d8ff9b97f0b43fef513">SPHERICAL_TESSELATION</a>
, <a class="el" href="tesselator__bonus_8h.html#a35dd9ea512bda830c7abbe9a8582cba6af0200f5e8e418750503ae04e561555d8">CYLINDRICAL_TESSELATION</a>
 }</td></tr>
<tr class="memdesc:a35dd9ea512bda830c7abbe9a8582cba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for typedef <b>t_tesselation_type</b>.  <a href="tesselator__bonus_8h.html#a35dd9ea512bda830c7abbe9a8582cba6">More...</a><br /></td></tr>
<tr class="separator:a35dd9ea512bda830c7abbe9a8582cba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2255e306b437f412cbf8c20bd24c2d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a2255e306b437f412cbf8c20bd24c2d1e">fdf_create_object</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> **map_mx)</td></tr>
<tr class="memdesc:a2255e306b437f412cbf8c20bd24c2d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_create_object</b> &ndash; TODO.  <a href="tesselator__bonus_8h.html#a2255e306b437f412cbf8c20bd24c2d1e">More...</a><br /></td></tr>
<tr class="separator:a2255e306b437f412cbf8c20bd24c2d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5451f47b36893293c0204d724928008f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a5451f47b36893293c0204d724928008f">fdf_destroy_object</a> (<a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *object)</td></tr>
<tr class="memdesc:a5451f47b36893293c0204d724928008f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_destroy_object</b> &ndash; TODO.  <a href="tesselator__bonus_8h.html#a5451f47b36893293c0204d724928008f">More...</a><br /></td></tr>
<tr class="separator:a5451f47b36893293c0204d724928008f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7949ee6e508cb7d7d25233d727a88ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#ac7949ee6e508cb7d7d25233d727a88ed">fdf_tesselate_map</a> (<a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *object)</td></tr>
<tr class="memdesc:ac7949ee6e508cb7d7d25233d727a88ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_tesselate_map</b> &ndash; TODO.  <a href="tesselator__bonus_8h.html#ac7949ee6e508cb7d7d25233d727a88ed">More...</a><br /></td></tr>
<tr class="separator:ac7949ee6e508cb7d7d25233d727a88ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd20646d0590ef38621345e51a8a152f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#abd20646d0590ef38621345e51a8a152f">fdf_get_edge</a> (<a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *object)</td></tr>
<tr class="memdesc:abd20646d0590ef38621345e51a8a152f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_get_edge</b> &ndash; TODO.  <a href="tesselator__bonus_8h.html#abd20646d0590ef38621345e51a8a152f">More...</a><br /></td></tr>
<tr class="separator:abd20646d0590ef38621345e51a8a152f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8f164941866827e4d3aa873f53cb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a6f8f164941866827e4d3aa873f53cb0c">fdf_create_rot_mx</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:a6f8f164941866827e4d3aa873f53cb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_create_rot_mx</b> &ndash; TODO.  <a href="tesselator__bonus_8h.html#a6f8f164941866827e4d3aa873f53cb0c">More...</a><br /></td></tr>
<tr class="separator:a6f8f164941866827e4d3aa873f53cb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5499e807ec235642a9735331b7aef2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a5499e807ec235642a9735331b7aef2ea">fdf_create_ortoproj_mx</a> (void)</td></tr>
<tr class="memdesc:a5499e807ec235642a9735331b7aef2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_create_ortoproj</b> &ndash; Creates an transformation matrix for ortographic projection to the XY-plane.  <a href="tesselator__bonus_8h.html#a5499e807ec235642a9735331b7aef2ea">More...</a><br /></td></tr>
<tr class="separator:a5499e807ec235642a9735331b7aef2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793723082acc2151075b1660051aed94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a793723082acc2151075b1660051aed94">fdf_create_transl_mx</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:a793723082acc2151075b1660051aed94"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_create_transl_mx</b> &ndash; Creates a translation matrix.  <a href="tesselator__bonus_8h.html#a793723082acc2151075b1660051aed94">More...</a><br /></td></tr>
<tr class="separator:a793723082acc2151075b1660051aed94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35be888bf0bafe70ce790f111c1b016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#ae35be888bf0bafe70ce790f111c1b016">fdf_create_scale_mx</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:ae35be888bf0bafe70ce790f111c1b016"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_create_scale_mx</b> &ndash; Flip along the row axis (y axis).  <a href="tesselator__bonus_8h.html#ae35be888bf0bafe70ce790f111c1b016">More...</a><br /></td></tr>
<tr class="separator:ae35be888bf0bafe70ce790f111c1b016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec66f34a8ebb02eaa97625530b488683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#aec66f34a8ebb02eaa97625530b488683">fdf_print_edges</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *map_mx, <a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *object, <a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *v_mx)</td></tr>
<tr class="memdesc:aec66f34a8ebb02eaa97625530b488683"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_print_edges</b> &ndash; TODO.  <a href="tesselator__bonus_8h.html#aec66f34a8ebb02eaa97625530b488683">More...</a><br /></td></tr>
<tr class="separator:aec66f34a8ebb02eaa97625530b488683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c0265c2471985c6324087e6d58402a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tesselator__bonus_8h.html#a67794afb8c91e77cdbeb21389edf5eda">t_fdf_plane</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#ab1c0265c2471985c6324087e6d58402a">fdf_create_plane</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *a, <a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *b, <a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *c)</td></tr>
<tr class="memdesc:ab1c0265c2471985c6324087e6d58402a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_create_plane</b> &ndash; Creates a plane from 3 vertexes.  <a href="tesselator__bonus_8h.html#ab1c0265c2471985c6324087e6d58402a">More...</a><br /></td></tr>
<tr class="separator:ab1c0265c2471985c6324087e6d58402a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74a326976603645afba8d25fb60a9f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#ac74a326976603645afba8d25fb60a9f0">fdf_point_is_in_plane</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *v, <a class="el" href="tesselator__bonus_8h.html#a67794afb8c91e77cdbeb21389edf5eda">t_fdf_plane</a> *plane)</td></tr>
<tr class="memdesc:ac74a326976603645afba8d25fb60a9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_point_is_in_plane</b> &ndash; Evaluates if a vertex belongs to a plane.  <a href="tesselator__bonus_8h.html#ac74a326976603645afba8d25fb60a9f0">More...</a><br /></td></tr>
<tr class="separator:ac74a326976603645afba8d25fb60a9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3f6cbe5f770040ff43f3e19b6d3824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tesselator__bonus_8h.html#a11a91978956247bd2a59360803b13c7e">t_fdf_3drect</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a1a3f6cbe5f770040ff43f3e19b6d3824">fdf_create_3drect</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *v1, <a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *v2)</td></tr>
<tr class="memdesc:a1a3f6cbe5f770040ff43f3e19b6d3824"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_create_3drect</b> &ndash; Creates 3D rect equation parameter struct from two 3D points.  <a href="tesselator__bonus_8h.html#a1a3f6cbe5f770040ff43f3e19b6d3824">More...</a><br /></td></tr>
<tr class="separator:a1a3f6cbe5f770040ff43f3e19b6d3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef7f4fd0fc237394eec0d965e0eb2ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#aeef7f4fd0fc237394eec0d965e0eb2ef">fdf_getz_3drect_fromx</a> (double *z, <a class="el" href="tesselator__bonus_8h.html#a11a91978956247bd2a59360803b13c7e">t_fdf_3drect</a> *rect, double x)</td></tr>
<tr class="memdesc:aeef7f4fd0fc237394eec0d965e0eb2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_getz_3drect_fromx</b> &ndash; Gets Z value from rect equation given the X value.  <a href="tesselator__bonus_8h.html#aeef7f4fd0fc237394eec0d965e0eb2ef">More...</a><br /></td></tr>
<tr class="separator:aeef7f4fd0fc237394eec0d965e0eb2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88985cd392160c4890b9edad07f96a31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a88985cd392160c4890b9edad07f96a31">fdf_getz_3drect_fromy</a> (double *z, <a class="el" href="tesselator__bonus_8h.html#a11a91978956247bd2a59360803b13c7e">t_fdf_3drect</a> *rect, double y)</td></tr>
<tr class="memdesc:a88985cd392160c4890b9edad07f96a31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_getz_3drect_fromy</b> &ndash; Gets Z value from rect equation given the Y value.  <a href="tesselator__bonus_8h.html#a88985cd392160c4890b9edad07f96a31">More...</a><br /></td></tr>
<tr class="separator:a88985cd392160c4890b9edad07f96a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c6fb1de5fe97feebbf34d2dee3e4ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a49c6fb1de5fe97feebbf34d2dee3e4ef">fdf_set_diag_edge_validity</a> (int this_edge, <a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *obj, int ort_v1, int ort_v2)</td></tr>
<tr class="memdesc:a49c6fb1de5fe97feebbf34d2dee3e4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_set_diag_edge_validity</b> &ndash; TODO.  <a href="tesselator__bonus_8h.html#a49c6fb1de5fe97feebbf34d2dee3e4ef">More...</a><br /></td></tr>
<tr class="separator:a49c6fb1de5fe97feebbf34d2dee3e4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb6fba0e702d7154719db63c561c1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#acbb6fba0e702d7154719db63c561c1a9">fdf_get_vertex_mx</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *z_mx)</td></tr>
<tr class="memdesc:acbb6fba0e702d7154719db63c561c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_get_vertex_mx</b> &ndash; Converts an altitude map matrix and color map matrix to a planar vertex matrix.  <a href="tesselator__bonus_8h.html#acbb6fba0e702d7154719db63c561c1a9">More...</a><br /></td></tr>
<tr class="separator:acbb6fba0e702d7154719db63c561c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e7cbf4b07d1bda7f5148ba6ba07da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a26e7cbf4b07d1bda7f5148ba6ba07da8">fdf_get_vertex_mx_sph</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *z_mx, double r)</td></tr>
<tr class="memdesc:a26e7cbf4b07d1bda7f5148ba6ba07da8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_get_vertex_mx_sph</b> &ndash; Converts an altitude map matrix and color map matrix to a spherical vertex matrix.  <a href="tesselator__bonus_8h.html#a26e7cbf4b07d1bda7f5148ba6ba07da8">More...</a><br /></td></tr>
<tr class="separator:a26e7cbf4b07d1bda7f5148ba6ba07da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ef7e4b513e400f2d8d9c5671bddd33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a69ef7e4b513e400f2d8d9c5671bddd33">fdf_get_vertex_mx_cyl</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *z_mx, double r, double h)</td></tr>
<tr class="memdesc:a69ef7e4b513e400f2d8d9c5671bddd33"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_get_vertex_mx_cyl</b> &ndash; Converts an altitude map matrix and color map matrix to a cylindrical vertex matrix.  <a href="tesselator__bonus_8h.html#a69ef7e4b513e400f2d8d9c5671bddd33">More...</a><br /></td></tr>
<tr class="separator:a69ef7e4b513e400f2d8d9c5671bddd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d27b05dc51ce46991b6a13c6908a3d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tesselator__bonus_8h.html#a7c00f492f251160c49cdf977ea1c6367">t_fdf_nv</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a0d27b05dc51ce46991b6a13c6908a3d4">fdf_create_nv</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *diag_start, <a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *diag_end, <a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *ort1, <a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *ort2)</td></tr>
<tr class="memdesc:a0d27b05dc51ce46991b6a13c6908a3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_create_nv</b> &ndash; Creates a neighboring vertexes struct.  <a href="tesselator__bonus_8h.html#a0d27b05dc51ce46991b6a13c6908a3d4">More...</a><br /></td></tr>
<tr class="separator:a0d27b05dc51ce46991b6a13c6908a3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5285fd2bc29cd15f279fcca8741cc1e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a5285fd2bc29cd15f279fcca8741cc1e9">fdf_destroy_nv</a> (<a class="el" href="tesselator__bonus_8h.html#a7c00f492f251160c49cdf977ea1c6367">t_fdf_nv</a> *nv)</td></tr>
<tr class="memdesc:a5285fd2bc29cd15f279fcca8741cc1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_destroy_nv</b> &ndash; Destroys a neighboring vertexes struct.  <a href="tesselator__bonus_8h.html#a5285fd2bc29cd15f279fcca8741cc1e9">More...</a><br /></td></tr>
<tr class="separator:a5285fd2bc29cd15f279fcca8741cc1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32914b30a1a6934c2e99147c2e44fd37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesselator__bonus_8h.html#a32914b30a1a6934c2e99147c2e44fd37">fdf_get_vertex_min_max</a> (<a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *vertex_mx, double *min, double *max)</td></tr>
<tr class="memdesc:a32914b30a1a6934c2e99147c2e44fd37"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>fdf_get_vertex_min_max</b> &ndash; TODO.  <a href="tesselator__bonus_8h.html#a32914b30a1a6934c2e99147c2e44fd37">More...</a><br /></td></tr>
<tr class="separator:a32914b30a1a6934c2e99147c2e44fd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >TODO </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a26ef95a8eff7e68f9f4cc37f458c9326" name="a26ef95a8eff7e68f9f4cc37f458c9326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ef95a8eff7e68f9f4cc37f458c9326">&#9670;&nbsp;</a></span>RADIUS_RATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RADIUS_RATE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >TODO. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a11a91978956247bd2a59360803b13c7e" name="a11a91978956247bd2a59360803b13c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a91978956247bd2a59360803b13c7e">&#9670;&nbsp;</a></span>t_fdf_3drect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#a11a91978956247bd2a59360803b13c7e">t_fdf_3drect</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Based on the <a class="el" href="structs__fdf__3drect.html">s_fdf_3drect</a> struct TODO. </p>

</div>
</div>
<a id="a997a884aebfbd35b8c746e1dabb7f3c4" name="a997a884aebfbd35b8c746e1dabb7f3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997a884aebfbd35b8c746e1dabb7f3c4">&#9670;&nbsp;</a></span>t_fdf_edge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#a997a884aebfbd35b8c746e1dabb7f3c4">t_fdf_edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Based on the <a class="el" href="structs__fdf__edge.html">s_fdf_edge</a> struct that stores the indexes ofa vertex matrix that correspond to and edge as well as its desired visibility. </p>

</div>
</div>
<a id="a7c00f492f251160c49cdf977ea1c6367" name="a7c00f492f251160c49cdf977ea1c6367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c00f492f251160c49cdf977ea1c6367">&#9670;&nbsp;</a></span>t_fdf_nv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#a7c00f492f251160c49cdf977ea1c6367">t_fdf_nv</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Based on the <a class="el" href="structs__fdf__nv.html">s_fdf_nv</a> struct TODO. </p>

</div>
</div>
<a id="ac4ed0c56ef8fb06d8186b340101a1d7f" name="ac4ed0c56ef8fb06d8186b340101a1d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ed0c56ef8fb06d8186b340101a1d7f">&#9670;&nbsp;</a></span>t_fdf_object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Based on the <a class="el" href="structs__fdf__object.html">s_fdf_object</a> struct TODO. </p>

</div>
</div>
<a id="a67794afb8c91e77cdbeb21389edf5eda" name="a67794afb8c91e77cdbeb21389edf5eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67794afb8c91e77cdbeb21389edf5eda">&#9670;&nbsp;</a></span>t_fdf_plane</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#a67794afb8c91e77cdbeb21389edf5eda">t_fdf_plane</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Based on the <a class="el" href="structs__fdf__plane.html">s_fdf_plane</a> struct TODO. </p>

</div>
</div>
<a id="a7b90bf626ce47bf7731feaed57fe4b2c" name="a7b90bf626ce47bf7731feaed57fe4b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b90bf626ce47bf7731feaed57fe4b2c">&#9670;&nbsp;</a></span>t_fdf_triangle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#a7b90bf626ce47bf7731feaed57fe4b2c">t_fdf_triangle</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Based on the <a class="el" href="structs__fdf__triangle.html">s_fdf_triangle</a> struct TODO. </p>

</div>
</div>
<a id="af3c0e397419104bde80dd7464cc5266a" name="af3c0e397419104bde80dd7464cc5266a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c0e397419104bde80dd7464cc5266a">&#9670;&nbsp;</a></span>t_tesselation_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#af3c0e397419104bde80dd7464cc5266a">t_tesselation_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Based on the <a class="el" href="tesselator__bonus_8h.html#a35dd9ea512bda830c7abbe9a8582cba6">e_tesselation_type</a> enum to indicate the tesselation type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a35dd9ea512bda830c7abbe9a8582cba6" name="a35dd9ea512bda830c7abbe9a8582cba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dd9ea512bda830c7abbe9a8582cba6">&#9670;&nbsp;</a></span>e_tesselation_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tesselator__bonus_8h.html#a35dd9ea512bda830c7abbe9a8582cba6">e_tesselation_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base for typedef <b>t_tesselation_type</b>. </p>
<p >This type is used in function <a class="el" href="tesselator__bonus_8h.html#ac7949ee6e508cb7d7d25233d727a88ed" title="fdf_tesselate_map – TODO.">fdf_tesselate_map()</a> to indicate how the map_mx matrix parsed from file must be transformed into a 3D object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a35dd9ea512bda830c7abbe9a8582cba6ae6396c2dda7d51b8e4f6f316752bcbb7" name="a35dd9ea512bda830c7abbe9a8582cba6ae6396c2dda7d51b8e4f6f316752bcbb7"></a>PLANE_TESSELATION&#160;</td><td class="fielddoc"><p >Indicates that the X, Y and altitud values derived from the map_mx matrix defines a horizontal XY plane with map's altitudes varying the Z values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a35dd9ea512bda830c7abbe9a8582cba6ab38056c07f064d8ff9b97f0b43fef513" name="a35dd9ea512bda830c7abbe9a8582cba6ab38056c07f064d8ff9b97f0b43fef513"></a>SPHERICAL_TESSELATION&#160;</td><td class="fielddoc"><p >Indicates that the X, Y and altitud values derived from the map_mx matrix defines a sphere with map's altitudes varying its radius from a base_radius. </p>
</td></tr>
<tr><td class="fieldname"><a id="a35dd9ea512bda830c7abbe9a8582cba6af0200f5e8e418750503ae04e561555d8" name="a35dd9ea512bda830c7abbe9a8582cba6af0200f5e8e418750503ae04e561555d8"></a>CYLINDRICAL_TESSELATION&#160;</td><td class="fielddoc"><p >Indicates that the X, Y and altitud values derived from the map_mx matrix defines a cylinder along Z axis with map's altitudes varying its radius from a base_radius. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1a3f6cbe5f770040ff43f3e19b6d3824" name="a1a3f6cbe5f770040ff43f3e19b6d3824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3f6cbe5f770040ff43f3e19b6d3824">&#9670;&nbsp;</a></span>fdf_create_3drect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#a11a91978956247bd2a59360803b13c7e">t_fdf_3drect</a> * fdf_create_3drect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_create_3drect</b> &ndash; Creates 3D rect equation parameter struct from two 3D points. </p>
<p >TODO If the rect is perpendicular to X axis (i.e. parallel to YZ), that is tx = 0 (tx = rect-&gt;x2 - rect-&gt;x1), it is impossible to obtain the Z value from a X value. This is because for a given X value there is no unique (actually infinite) Z value that checks the rect equation. If this is the case, NULL is returned. <br  />
 Otherwise (tx != 0), if it is perpendicular to Z axis (i.e. parallel to XY), that is tz = 0 (tz = rect-&gt;z2 - rect-&gt;z1), the solution is already in rect-&gt;parallel_to_xy_at_z and is independent from the value of passed x. <br  />
 In the rest of cases the z value is calculated from: <br  />
 z = ((x - x1) / tx ) * tz) + z1 <br  />
 TODO </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>- The first vertex (as a column vector matrix) that belongs to the rect whose equation parameters will be calculated.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>- The second vertex (as a column vector matrix) that belongs to the rect whose equation parameters will be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the struct that stores the parameters of the rect equation to which the both vertexes belong. <br  />
 NULL if giving the two passed points it is impossible a rect that goes through both.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Caller must free the returned pointer. TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: The <a class="el" href="tesselator__bonus_8h.html#a1a3f6cbe5f770040ff43f3e19b6d3824" title="fdf_create_3drect – Creates 3D rect equation parameter struct from two 3D points.">fdf_create_3drect()</a> function already calculates the auxiliary members of the 3drect struct that report parallelism/perpendicularity with 2-axis-planes/axis. This members are used for legibilty: parallel_to_xy, parallel_to_xy_at_z, parallel_to_yz, parallel_to_yz_at_x, parallel_to_xz, and parallel_to_xz_at_y. <a href="https://www.geeksforgeeks.org/equation-of-a-line-in-3d/">https://www.geeksforgeeks.org/equation-of-a-line-in-3d/</a> <a href="https://math.stackexchange.com/questions/4496965/">https://math.stackexchange.com/questions/4496965/</a> how-to-find-the-equation-of-a-3d-straight-line-when-given-two-points </dd></dl>

</div>
</div>
<a id="a0d27b05dc51ce46991b6a13c6908a3d4" name="a0d27b05dc51ce46991b6a13c6908a3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d27b05dc51ce46991b6a13c6908a3d4">&#9670;&nbsp;</a></span>fdf_create_nv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#a7c00f492f251160c49cdf977ea1c6367">t_fdf_nv</a> * fdf_create_nv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>diag_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>diag_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>ort1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>ort2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_create_nv</b> &ndash; Creates a neighboring vertexes struct. </p>
<p >Creates a neighboring vertexes struct by allocating memory for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_start</td><td>- The vertex as a column-vector matrix from which the diagonal being analyzed starts.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_end</td><td>- The vertex as a column-vector matrix to which the diagonal being analyzed ends.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ort1</td><td>- One of the orthogonal neighbor vertexes (as a column-vector matrix) to the diag_start vertex. It could be its down neighbor or either the left or right neighbor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ort2</td><td>- The other orthogonal neighbor vertexes (as a column-vector matrix) to the diag_start vertex. It could be its down neighbor or either the left or right neighbor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighboring vertexes structure. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="a2255e306b437f412cbf8c20bd24c2d1e" name="a2255e306b437f412cbf8c20bd24c2d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2255e306b437f412cbf8c20bd24c2d1e">&#9670;&nbsp;</a></span>fdf_create_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> * fdf_create_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> **&#160;</td>
          <td class="paramname"><em>map_mx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_create_object</b> &ndash; TODO. </p>
<p >TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_mx</td><td>A pointer to an array of two matrices with the raw data (altitude values at each row, column coordinate; and color values) from which the tesselation is done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object with planar tesselation. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="a5499e807ec235642a9735331b7aef2ea" name="a5499e807ec235642a9735331b7aef2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5499e807ec235642a9735331b7aef2ea">&#9670;&nbsp;</a></span>fdf_create_ortoproj_mx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> * fdf_create_ortoproj_mx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_create_ortoproj</b> &ndash; Creates an transformation matrix for ortographic projection to the XY-plane. </p>
<p >Basically a 3x3 identity matrix with id22 as zero. TODO.</p>
<p >De wiki (<a href="https://en.wikipedia.org/wiki/Rotation_matrix">https://en.wikipedia.org/wiki/Rotation_matrix</a>): R = RzRyRx These matrices produce the desired effect only if they are used to premultiply column vectors, and (since in general matrix multiplication is not commutative) only if they are applied in the specified order (see Ambiguities for more details). The order of rotation operations is from right to left; the matrix adjacent to the column vector is the first to be applied, and then the one to the left.[3] ... Pre-multiplication or post-multiplication The same point P can be represented either by a column vector v or a row vector w. Rotation matrices can either pre-multiply column vectors (Rv), or post-multiply row vectors (wR). However, Rv produces a rotation in the opposite direction with respect to wR. Throughout this article, rotations produced on column vectors are described by means of a pre-multiplication. To obtain exactly the same rotation (i.e. the same final coordinates of point P), the equivalent row vector must be post-multiplied by the transpose of R (i.e. wRT).</p>
<dl class="section return"><dt>Returns</dt><dd>TODO.. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="ab1c0265c2471985c6324087e6d58402a" name="ab1c0265c2471985c6324087e6d58402a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c0265c2471985c6324087e6d58402a">&#9670;&nbsp;</a></span>fdf_create_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tesselator__bonus_8h.html#a67794afb8c91e77cdbeb21389edf5eda">t_fdf_plane</a> * fdf_create_plane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_create_plane</b> &ndash; Creates a plane from 3 vertexes. </p>
<p >TODO.</p>
<p ><a href="https://math.stackexchange.com/questions/2686606/">https://math.stackexchange.com/questions/2686606/</a> equation-of-a-plane-passing-through-3-points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>- One of the vertexes that belongs to the plane as a column vector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>- One of the vertexes that belongs to the plane as a column vector.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- One of the vertexes that belongs to the plane as a column vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="a6f8f164941866827e4d3aa873f53cb0c" name="a6f8f164941866827e4d3aa873f53cb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8f164941866827e4d3aa873f53cb0c">&#9670;&nbsp;</a></span>fdf_create_rot_mx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> * fdf_create_rot_mx </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_create_rot_mx</b> &ndash; TODO. </p>
<p >TODO.</p>
<p >De wiki (<a href="https://en.wikipedia.org/wiki/Rotation_matrix">https://en.wikipedia.org/wiki/Rotation_matrix</a>): R = RzRyRx These matrices produce the desired effect only if they are used to premultiply column vectors, and (since in general matrix multiplication is not commutative) only if they are applied in the specified order (see Ambiguities for more details). The order of rotation operations is from right to left; the matrix adjacent to the column vector is the first to be applied, and then the one to the left.[3] ... Pre-multiplication or post-multiplication The same point P can be represented either by a column vector v or a row vector w. Rotation matrices can either pre-multiply column vectors (Rv), or post-multiply row vectors (wR). However, Rv produces a rotation in the opposite direction with respect to wR. Throughout this article, rotations produced on column vectors are described by means of a pre-multiplication. To obtain exactly the same rotation (i.e. the same final coordinates of point P), the equivalent row vector must be post-multiplied by the transpose of R (i.e. wRT).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>- Rotation degree along the X axis.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>- Rotation degree along the Y axis.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>- Rotation degree along the Z axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="ae35be888bf0bafe70ce790f111c1b016" name="ae35be888bf0bafe70ce790f111c1b016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35be888bf0bafe70ce790f111c1b016">&#9670;&nbsp;</a></span>fdf_create_scale_mx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> * fdf_create_scale_mx </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_create_scale_mx</b> &ndash; Flip along the row axis (y axis). </p>
<p >TODO.</p>
<p >De wiki (<a href="https://en.wikipedia.org/wiki/Rotation_matrix">https://en.wikipedia.org/wiki/Rotation_matrix</a>): R = RzRyRx These matrices produce the desired effect only if they are used to premultiply column vectors, and (since in general matrix multiplication is not commutative) only if they are applied in the specified order (see Ambiguities for more details). The order of rotation operations is from right to left; the matrix adjacent to the column vector is the first to be applied, and then the one to the left.[3] ... Pre-multiplication or post-multiplication The same point P can be represented either by a column vector v or a row vector w. Rotation matrices can either pre-multiply column vectors (Rv), or post-multiply row vectors (wR). However, Rv produces a rotation in the opposite direction with respect to wR. Throughout this article, rotations produced on column vectors are described by means of a pre-multiplication. To obtain exactly the same rotation (i.e. the same final coordinates of point P), the equivalent row vector must be post-multiplied by the transpose of R (i.e. wRT).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>- The scale factor for X axis.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>- The scale factor for Y axis.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>- The scale factor for Z axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="a793723082acc2151075b1660051aed94" name="a793723082acc2151075b1660051aed94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793723082acc2151075b1660051aed94">&#9670;&nbsp;</a></span>fdf_create_transl_mx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> * fdf_create_transl_mx </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_create_transl_mx</b> &ndash; Creates a translation matrix. </p>
<p >TODO.</p>
<p >De wiki (<a href="https://en.wikipedia.org/wiki/Rotation_matrix">https://en.wikipedia.org/wiki/Rotation_matrix</a>): R = RzRyRx These matrices produce the desired effect only if they are used to premultiply column vectors, and (since in general matrix multiplication is not commutative) only if they are applied in the specified order (see Ambiguities for more details). The order of rotation operations is from right to left; the matrix adjacent to the column vector is the first to be applied, and then the one to the left.[3] ... Pre-multiplication or post-multiplication The same point P can be represented either by a column vector v or a row vector w. Rotation matrices can either pre-multiply column vectors (Rv), or post-multiply row vectors (wR). However, Rv produces a rotation in the opposite direction with respect to wR. Throughout this article, rotations produced on column vectors are described by means of a pre-multiplication. To obtain exactly the same rotation (i.e. the same final coordinates of point P), the equivalent row vector must be post-multiplied by the transpose of R (i.e. wRT).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>- The translation offset for X axis.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>- The translation offset for Y axis.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>- The translation offset for Z axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="a5285fd2bc29cd15f279fcca8741cc1e9" name="a5285fd2bc29cd15f279fcca8741cc1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5285fd2bc29cd15f279fcca8741cc1e9">&#9670;&nbsp;</a></span>fdf_destroy_nv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdf_destroy_nv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#a7c00f492f251160c49cdf977ea1c6367">t_fdf_nv</a> *&#160;</td>
          <td class="paramname"><em>nv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_destroy_nv</b> &ndash; Destroys a neighboring vertexes struct. </p>
<p >Destroys a neighboring vertexes struct by de-allocating memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nv</td><td>- The neihgbor vertexes structure pointer to be de-allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="a5451f47b36893293c0204d724928008f" name="a5451f47b36893293c0204d724928008f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5451f47b36893293c0204d724928008f">&#9670;&nbsp;</a></span>fdf_destroy_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdf_destroy_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_destroy_object</b> &ndash; TODO. </p>
<p >TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>- The pointer to the object to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="abd20646d0590ef38621345e51a8a152f" name="abd20646d0590ef38621345e51a8a152f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd20646d0590ef38621345e51a8a152f">&#9670;&nbsp;</a></span>fdf_get_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fdf_get_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_get_edge</b> &ndash; TODO. </p>
<p >TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>- The pointer to the 3D object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if correct. Value of 0 if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: This goes through each element of map_mx, which is a vertex. For each element it tries to add 3 edges to neighbors elements: right, down, and diagonal down-right. The later is set as hidden.</dd></dl>
<p>The iteration depends on the order in which <a class="el" href="tesselator__bonus_8h.html#acbb6fba0e702d7154719db63c561c1a9" title="fdf_get_vertex_mx – Converts an altitude map matrix and color map matrix to a planar vertex matrix.">fdf_get_vertex_mx()</a> walks through map_mx while adding the vertexes in vertex_mx: rows (i.e. 'i') increases first.</p>
<p >The number of edges comes from adding up:</p><ul>
<li>For every row (except for the last row) and for every element in that row (except the last element in row), 3 new edges are formed (down, right, and down-right).</li>
<li>Same as above, mutatis mutandi, to form only one down-left edge per vertex.</li>
<li>The last element in every row only forms 1 edge to down neighbor, except for the last element of the last row which forms NO new edge.</li>
<li>Every element in last row only forms 1 edge to right neighbor, except for the last element in this last row which forms NO new edge. </li>
</ul>

</div>
</div>
<a id="a32914b30a1a6934c2e99147c2e44fd37" name="a32914b30a1a6934c2e99147c2e44fd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32914b30a1a6934c2e99147c2e44fd37">&#9670;&nbsp;</a></span>fdf_get_vertex_min_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdf_get_vertex_min_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>vertex_mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_get_vertex_min_max</b> &ndash; TODO. </p>
<p >TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_mx</td><td>- The vertex matrix to analyze.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>- The size 3 array of double type to store the minimum values found for each axis (0:X: 1:Y; 2:Z) in the vertex matrix. There is no need to initialize this array before calling the function.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>- The size 3 array of double type to store the maximum values found for each axis (0:X: 1:Y; 2:Z) in the vertex matrix. There is no need to initialize this array before calling the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="acbb6fba0e702d7154719db63c561c1a9" name="acbb6fba0e702d7154719db63c561c1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb6fba0e702d7154719db63c561c1a9">&#9670;&nbsp;</a></span>fdf_get_vertex_mx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> * fdf_get_vertex_mx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>z_mx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_get_vertex_mx</b> &ndash; Converts an altitude map matrix and color map matrix to a planar vertex matrix. </p>
<p >This function takes an array of two pointer to matrices that represent the values for both altitude and color of samples at an equidistant normalized X (colum number) and Y (row number) coordinates and returns another matrix in which every column represents a col-vector with the values corresponding to a xyzw vertex (row 0 to 3, respectively). This conversion maintains the planar correspondence of the source map matrix to the surface it refers to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z_mx</td><td>- The altitude map matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertex matrix if OK. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: The vertex_mx is a col-vector matrix where each column represents a xyzw vertex (each row, from top to bottom, has one of these components). The order in which the vertex matrix is filled (which vertex is first included as a column, then the second...) is the following: the first vertex corresponds to the map_mx-&gt;d[0] (which is row 0, column 0 from the addressing style map_mx-&gt;d[i * map_mx-n + j]). Then i (i.e. 'y') is increased while j (i.e. 'x' remains at 0)... In conclusion: map_mx is walked through by increasing the row (i.e. increasing the vertex's 'y' coordinate). TODO. </dd></dl>

</div>
</div>
<a id="a69ef7e4b513e400f2d8d9c5671bddd33" name="a69ef7e4b513e400f2d8d9c5671bddd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ef7e4b513e400f2d8d9c5671bddd33">&#9670;&nbsp;</a></span>fdf_get_vertex_mx_cyl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> * fdf_get_vertex_mx_cyl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>z_mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_get_vertex_mx_cyl</b> &ndash; Converts an altitude map matrix and color map matrix to a cylindrical vertex matrix. </p>
<p >This function takes an array of two pointer to matrices that represent the values for both altitude and color of samples at an equidistant normalized X (colum number) and Y (row number) coordinates and returns another matrix in which every column represents a col-vector with the values corresponding to a xyzw vertex (row 0 to 3, respectively). This conversion turns the planar correspondence of the source map matrix to the surface it refers to into a cylindrical representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z_mx</td><td>- The altitude map matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>- The cylinder base radius that will be modulated by the altitude values from the map matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>- The cylinder height.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertex matrix if OK. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="a26e7cbf4b07d1bda7f5148ba6ba07da8" name="a26e7cbf4b07d1bda7f5148ba6ba07da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e7cbf4b07d1bda7f5148ba6ba07da8">&#9670;&nbsp;</a></span>fdf_get_vertex_mx_sph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> * fdf_get_vertex_mx_sph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>z_mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_get_vertex_mx_sph</b> &ndash; Converts an altitude map matrix and color map matrix to a spherical vertex matrix. </p>
<p >This function takes an array of two pointer to matrices that represent the values for both altitude and color of samples at an equidistant normalized X (colum number) and Y (row number) coordinates and returns another matrix in which every column represents a col-vector with the values corresponding to a xyzw vertex (row 0 to 3, respectively). This conversion turns the planar correspondence of the source map matrix to the surface it refers to into a spherical representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z_mx</td><td>- The altitude map matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>- The sphere base radius that will be modulated by the altitude values from the map matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertex matrix if OK. NULL if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="aeef7f4fd0fc237394eec0d965e0eb2ef" name="aeef7f4fd0fc237394eec0d965e0eb2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef7f4fd0fc237394eec0d965e0eb2ef">&#9670;&nbsp;</a></span>fdf_getz_3drect_fromx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fdf_getz_3drect_fromx </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#a11a91978956247bd2a59360803b13c7e">t_fdf_3drect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_getz_3drect_fromx</b> &ndash; Gets Z value from rect equation given the X value. </p>
<p >If the rect is perpendicular to X axis (i.e. parallel to YZ), that is tx = 0 (tx = rect-&gt;x2 - rect-&gt;x1), it is impossible to obtain the Z value from a X value. This is because for a given X value there is no unique (actually infinite) Z value that checks the rect equation. If this is the case, NULL is returned. <br  />
 Otherwise (tx != 0), if it is perpendicular to Z axis (i.e. parallel to XY), that is tz = 0 (tz = rect-&gt;z2 - rect-&gt;z1), the solution is already in rect-&gt;parallel_to_xy_at_z and is independent from the value of passed x. <br  />
</p>
<p >TODO review code's special case and re-write this...</p>
<p >For the rest of cases the z value is calculated from: <br  />
 z = ((x - x1) / tx ) * tz) + z1 <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>- The pointer to a double to store the z value if possible.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>- The struct with the parameters of the 3D rect equation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>- The value of the X coordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if pointer to the Z value is valid. A zero value if impossible to return Z coordinate value from an X coordinate value. <br  />
 In this case rect-&gt;parallel_to_xy and rect-&gt;parallel_to_xy_at_z must be checked.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Caller must free the returned pointer. TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: The <a class="el" href="tesselator__bonus_8h.html#a1a3f6cbe5f770040ff43f3e19b6d3824" title="fdf_create_3drect – Creates 3D rect equation parameter struct from two 3D points.">fdf_create_3drect()</a> function already calculates the auxiliary members of the 3drect struct that report parallelism/perpendicularity with axis/axis-planes. This members are used for legibilty: parallel_to_xy, parallel_to_xy_at_z, parallel_to_yz, parallel_to_yz_at_x, parallel_to_xz, and parallel_to_xz_at_y. <a href="https://www.geeksforgeeks.org/equation-of-a-line-in-3d/">https://www.geeksforgeeks.org/equation-of-a-line-in-3d/</a> <a href="https://math.stackexchange.com/questions/4496965/">https://math.stackexchange.com/questions/4496965/</a> how-to-find-the-equation-of-a-3d-straight-line-when-given-two-points </dd></dl>

</div>
</div>
<a id="a88985cd392160c4890b9edad07f96a31" name="a88985cd392160c4890b9edad07f96a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88985cd392160c4890b9edad07f96a31">&#9670;&nbsp;</a></span>fdf_getz_3drect_fromy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fdf_getz_3drect_fromy </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#a11a91978956247bd2a59360803b13c7e">t_fdf_3drect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_getz_3drect_fromy</b> &ndash; Gets Z value from rect equation given the Y value. </p>
<p >If the rect is perpendicular to Y axis (i.e. parallel to XZ), that is ty = 0 (ty = rect-&gt;y2 - rect-&gt;y1), it is impossible to obtain the Z value from a Y value. This is because for a given Y value there is no unique (actually infinite) Z value that checks the rect equation. If this is the case, NULL is returned. <br  />
 Otherwise (ty != 0), if it is perpendicular to Z axis (i.e. parallel to XY), that is tz = 0 (tz = rect-&gt;z2 - rect-&gt;z1), the solution is already in rect-&gt;parallel_to_xy_at_z and is independent from the value of passed y. <br  />
</p>
<p >TODO review code's special case and re-write this...</p>
<p >For the rest of cases the z value is calculated from: <br  />
 z = ((y - y1) / ty ) * tz) + z1 <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>- The pointer to a double to store the z value if possible.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>- The struct with the parameters of the 3D rect equation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>- The value of the Y coordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if pointer to the Z value is valid. A zero value if impossible to return Z coordinate value from an Y coordinate value. <br  />
 In this case rect-&gt;parallel_to_xy and rect-&gt;parallel_to_xy_at_z must be checked.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Caller must free the returned pointer. TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: The <a class="el" href="tesselator__bonus_8h.html#a1a3f6cbe5f770040ff43f3e19b6d3824" title="fdf_create_3drect – Creates 3D rect equation parameter struct from two 3D points.">fdf_create_3drect()</a> function already calculates the auxiliary members of the 3drect struct that report parallelism/perpendicularity with axis/axis-planes. This members are used for legibilty: parallel_to_xy, parallel_to_xy_at_z, parallel_to_yz, parallel_to_yz_at_x, parallel_to_xz, and parallel_to_xz_at_y. <a href="https://www.geeksforgeeks.org/equation-of-a-line-in-3d/">https://www.geeksforgeeks.org/equation-of-a-line-in-3d/</a> <a href="https://math.stackexchange.com/questions/4496965/">https://math.stackexchange.com/questions/4496965/</a> how-to-find-the-equation-of-a-3d-straight-line-when-given-two-points </dd></dl>

</div>
</div>
<a id="ac74a326976603645afba8d25fb60a9f0" name="ac74a326976603645afba8d25fb60a9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74a326976603645afba8d25fb60a9f0">&#9670;&nbsp;</a></span>fdf_point_is_in_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fdf_point_is_in_plane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#a67794afb8c91e77cdbeb21389edf5eda">t_fdf_plane</a> *&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_point_is_in_plane</b> &ndash; Evaluates if a vertex belongs to a plane. </p>
<p >TODO.</p>
<p ><a href="https://math.stackexchange.com/questions/2686606/">https://math.stackexchange.com/questions/2686606/</a> equation-of-a-plane-passing-through-3-points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>- The vertex (as a column vector matrix) to evaluate in the plane equation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane</td><td>- The parameters of the plane equation to use for evaluation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if point v belongs to plane. A zero if v does not belong to the plane.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="aec66f34a8ebb02eaa97625530b488683" name="aec66f34a8ebb02eaa97625530b488683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec66f34a8ebb02eaa97625530b488683">&#9670;&nbsp;</a></span>fdf_print_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fdf_print_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>map_mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lin__alg__bonus_8h.html#aec338d582b890c6160182b83296d747a">t_ft_mx</a> *&#160;</td>
          <td class="paramname"><em>v_mx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_print_edges</b> &ndash; TODO. </p>
<p >For debuggin purposes ONLY. This function prints the map_mx (optional), one of its space vertex matrix (model, world, camera...), and the list of edges in reference to the given space vertex matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_mx</td><td>- Optional, can be NULL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>- The object from which to print the data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v_mx</td><td>- The specific space vertex matrix of the object to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>For debuggin purposes ONLY.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
<a id="a49c6fb1de5fe97feebbf34d2dee3e4ef" name="a49c6fb1de5fe97feebbf34d2dee3e4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c6fb1de5fe97feebbf34d2dee3e4ef">&#9670;&nbsp;</a></span>fdf_set_diag_edge_validity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fdf_set_diag_edge_validity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>this_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ort_v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ort_v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_set_diag_edge_validity</b> &ndash; TODO. </p>
<p >TODO comments inside the function's definition file TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this_edge</td><td>- TODO.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">obj</td><td>- The object being tesselated.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ort_v1</td><td>- TODO.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ort_v2</td><td>- TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if OK. A zero value if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This should be a static auxiliary funcion to <a class="el" href="tesselator__bonus_8h.html#abd20646d0590ef38621345e51a8a152f" title="fdf_get_edge – TODO.">fdf_get_edge()</a>, but due to 42's norm constraints I had to put it as a publicly accessible function. TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="ac7949ee6e508cb7d7d25233d727a88ed" name="ac7949ee6e508cb7d7d25233d727a88ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7949ee6e508cb7d7d25233d727a88ed">&#9670;&nbsp;</a></span>fdf_tesselate_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fdf_tesselate_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesselator__bonus_8h.html#ac4ed0c56ef8fb06d8186b340101a1d7f">t_fdf_object</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>fdf_tesselate_map</b> &ndash; TODO. </p>
<p >This function is the first level of processing when rendering (and (every re-rendering that request to dive into this level, that is, when changing the current projection: planar, spherical, cylindrical). <br  />
 This function's duty is to call the right function to transform the map's matrix into the vertex matrix that constitutes the 3D model. From the same map matrix, the vertex matrix (the model) will be different according to the requested projection type. Every type of model (planar, spherical and cylindrical) consists of a vertex matrix representing points as XYZW values in a cartesian 3D space. A planar projection will result in a 3D model pretty analogous to the map matrix. The spherical and cylindrical models are the result of transforming the map's values (XYZ) to a sphere or cylinder with a radius that is modulated by the Z (height value) of the map. <br  />
 When first called, this function obtains a planar model vertex matrix; obtains the planar min max values for each component of the vertexes; and obtains the edge array, which is only made once and is independent from the projection type. This edge array consists of the information of which vertexes are connected to each other (that is, which lines, between vertexes will be eventually drawn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>- TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO. Zero value if error.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: TODO. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
