<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fdf: 42&#39;s fdf project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Fdf<span id="projectnumber">&#160;2024-11-12</span>
   </div>
   <div id="projectbrief">Fdf project for Campus 42</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">42's fdf project </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> Luis Luque (<a href="#" onclick="location.href='mai'+'lto:'+'llu'+'qu'+'e@s'+'tu'+'den'+'t.'+'42m'+'al'+'aga'+'.c'+'om'; return false;">lluqu<span class="obfuscator">.nosp@m.</span>e@st<span class="obfuscator">.nosp@m.</span>udent<span class="obfuscator">.nosp@m.</span>.42m<span class="obfuscator">.nosp@m.</span>alaga<span class="obfuscator">.nosp@m.</span>.com</a>) - 2024</p>
<p >Message to other 42 students: DO NOT COPY, get inspired!</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Building and execution</h1>
<p >Clone the repository using the url in the desired directory: </p><div class="fragment"><div class="line">~$ git clone github_url project_directory</div>
</div><!-- fragment --><p >Initialize the library submodule by running this in the project directory: </p><div class="fragment"><div class="line">~/project_directory$ git submodule update --init --recursive</div>
</div><!-- fragment --><p >For help on building options execute in the project directory: </p><div class="fragment"><div class="line">~/project_directory$ make help</div>
</div><!-- fragment --><p >For building the bonus version (recommended) run: </p><div class="fragment"><div class="line">~/project_directory$ make bonus</div>
</div><!-- fragment --><p >The above will build the executable as ~/project_directory/bin/bonus/fdf.</p>
<p >To run the bonus binary from the project directory loading a map included with the repo, run:</p>
<div class="fragment"><div class="line">~/project_directory$ bin/bonus/fdf data/mars.fdf</div>
</div><!-- fragment --><p >Once the program GUI is up, the terminal shows the instruction for user's interaction such as rotate, translate, etc. Something like this:</p>
<div class="fragment"><div class="line">* Press the ESCAPE key or clic the window&#39;s X button to exit.</div>
<div class="line">* Press the I, K, J, L, U, or O keys to rotate along each axis.</div>
<div class="line">* Press the T key to cycle through planar/spherical/cylindrical projections.</div>
<div class="line">* Press the D key to show/hide valid diagonal edges.</div>
<div class="line">* Press the H key to show/hide all hidden edges.</div>
<div class="line">* Press the C key to toggle rendering with color (if available) or</div>
<div class="line">  forcing monochromatic rendering.</div>
<div class="line">* Press the TAB key to turn on/off the autofit and center feature.</div>
<div class="line">    * With autofit disabled:</div>
<div class="line">        * Press W or S keys to change the scale/zoom.</div>
<div class="line">        * Use the arrow keys to translate (displace) the model:</div>
<div class="line">            * UP/DOWN to move the camera perspective along Z axis.</div>
<div class="line">            * LEFT/RIGHT to move the camera in each direction.</div>
<div class="line">            * LEFT/RIGHT simultanously with UP/DOWN to move the camera</div>
<div class="line">              perspective along X and Y axis.</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Introduction</h1>
<p >Wireframe model of landscape representation in isometric projection</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Directory tree</h1>
<pre class="fragment">./  
├── .gitignore              (to prevent undesired files to be stagged)
├── Doxyfile                (doxygen config file for doc generation)  
├── Makefile                (use 'make help' for instructions)  
├── README.md               (brief documentation)  
├── doc/                    (documentation extracted from comments in .h)  
│   ├── html/               (html documentation)  
│   │   ├── ...  
│   │   ├── index.html      (entry point for html documentation)  
│   │   ├── ...  
│   └── man/                (man pages documentation)  
│       └── man3/  
│           └── ...         (example of use: 'man -l ft_string.h.3')  
├── include/                (directory for public header files (.h))  
│   ├── ...  
│   └── ...  
├── src/                    (dir for source code and private header files)  
│   ├── ...  
│   │   ├── ...                 
│   │   └── ...  
│   └── ...                 (may be structured in several directories)  
│       ├── ...  
│       └── ...  
├── lib/                    (external libraries)  
│   ├── ...  
│   └── libft               (each library in its own directory)  
├── bin/                    (directory for project's binaries and tester)  
│   ├── ...  
│   └── ...                 (may be structured in several directories)  
├── obj/                    (dir for source code and private header files)  
│   ├── ...  
│   │   ├── ...  
│   │   └── ...  
│   └── ...                 (structured as in ./src)  
│       ├── ...  
│       └── ...  
├── data/                   (directory for non-source files)  
└── test/                   (test program src code, compiles to .bin/tester)
    ├── ...  
    ├── tester.c  
    └── ...  
</pre> <h1><a class="anchor" id="autotoc_md4"></a>
Compilation instructions</h1>
<p >Use ‘make help’ for instructions.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Program's data model</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
Conventions adopted</h2>
<ul>
<li>When rendering, the right-handed convention for drawing XYZ axis will be used, which implies: <br  />
 <div class="fragment"><div class="line">   +Z</div>
<div class="line">    |</div>
<div class="line">    |</div>
<div class="line">   / \</div>
<div class="line">  /   \</div>
<div class="line">+X     +Y</div>
</div><!-- fragment --></li>
<li>The correspondence of the map matrix to the image spatial-wise is as follows:<ul>
<li>Moving through a ROW is analogous to move along the X coordinate.<ul>
<li>The rightmost element in a row represents the altitude at X = 0.</li>
<li>The leftmost element in a row represents the altitude at the greatest positive value for axis X.<ul>
<li><em>The horizontal position corresponds to its axis (X).</em></li>
</ul>
</li>
</ul>
</li>
<li>Moving through a COLUMN is analogous to move along the Y coordinate.<ul>
<li>The top-most element in a column represents the altitude at Y = 0.</li>
<li>The bottom-most element in a column represents the altitude at the greatest positive value for axis Y.<ul>
<li><em>The vertical position corresponds to its ordinate (Y).</em></li>
</ul>
</li>
</ul>
</li>
<li>Briefly stated:<ul>
<li>The top-right element in the matrix corresponds to the altitude at XY origin (0,0).</li>
<li>The bottom-left element in the matrix corresponds to the altitude at (Xmax, Ymax). <div class="fragment"><div class="line">                &lt;&lt;&lt; X  </div>
<div class="line">  (Xmax,0) c0     cC (0,0)  </div>
<div class="line">        r0  A .... B   Y  </div>
<div class="line">            .      .   v  </div>
<div class="line">            .      .   v  </div>
<div class="line">        rR  C .... D   v  </div>
<div class="line">(Xmax,Ymax)          (0,Ymax)  </div>
<div class="line"> </div>
<div class="line">    B: (0,0)</div>
<div class="line">    A: (Xmax,0)</div>
<div class="line">    D: (0,Ymax)</div>
<div class="line">    C: (Xmax, Ymax)</div>
<div class="line"> </div>
<div class="line">          +Z</div>
<div class="line">           |</div>
<div class="line">           | B (top-right matrix element)</div>
<div class="line">          / \</div>
<div class="line">         /   \</div>
<div class="line">       +X     +Y</div>
</div><!-- fragment --></li>
</ul>
</li>
</ul>
</li>
<li>Matrices nomenclature follows the mathematics standard: <div class="fragment"><div class="line">i: row index, starts at 0 (NOT 1)</div>
<div class="line">j: col index, starts at 0 (NOT 1)</div>
<div class="line">m: number of rows</div>
<div class="line">n: number of cols</div>
<div class="line">Aij: Element in row i col j. NOTICE that row index comes first...</div>
<div class="line">        A00 A02 A03</div>
<div class="line">        A10 A11 A12</div>
<div class="line">        A20 A21 A22</div>
</div><!-- fragment --></li>
<li>When representing matrix-like data, the native C matrix[i][j] approach (where matrix is of **double type) is not used, because that implies an array of array of pointers to memory in the HEAP which could "physically" be anywhere (no contiguous blocks). A single array of *double type was chosen instead to represent the elements of a matrix in a sequential fashion assuring all the data to be in the same memory block. This linear representation of a matrix consists of store in a unidimensional array all the elements of a matrix one after, that is, first all the elements of a row/col, followed by all the elements of the next row/col, etc. Choosing between row-by-row or col-by-col in this context is called row-major order (aka lexicographic order) or column-major order (aka colexicographic order) respectively.</li>
</ul>
<p >The convention used here is the row-major order (aka lexicographic order; aka row-by-row).</p>
<p >The element addressing of an intuitive C-style matrix (array of arrays, e.g. **double or double[][]) translates to this addressing: Given a m x n (rows x columns matrix, the element Aij is addressed in this way... </p><div class="fragment"><div class="line">Intuitive C-style matrix    Linear storage (row-major order)</div>
<div class="line"> </div>
<div class="line">     double **data;                   double *data;</div>
<div class="line"> </div>
<div class="line">       data[i][j] &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; data[i * n + j]</div>
</div><!-- fragment --><p> For example, a 2 x 5 matrix as it appears in the .fdf file:</p>
<p >As matrix format: </p><div class="fragment"><div class="line">10    11    12    13    14</div>
<div class="line">15    16    17    18    19</div>
</div><!-- fragment --><p> As it is actually storaged in memory as a unidimensional array using the row-major order (aka lexicographic order; aka row-by-row):</p>
<p ><b>10 11 12 13 14</b> 15 16 17 18 19</p><ul>
<li>When representing a vertex matrix, that is, the result of interpreting the map matrix as XYZW points (<em>the W component is a prevision for the future</em>), each point data is storaged (<b>idiotically</b>) as a column vector (<b>a row vector makes more sense when my whole freaking point is to optimize the calculations this is a major TODO for the future</b>):</li>
</ul>
<p >As matrix format: </p><div class="fragment"><div class="line"> 0     1     2     3     4     0     1     2     3     4</div>
<div class="line"> 0     0     0     0     0     1     1     1     1     1</div>
<div class="line">10    11    12    13    14    15    16    17    18    19</div>
<div class="line"> 1     1     1     1     1     1     1     1     1     1</div>
</div><!-- fragment --><p> As it is actually storaged in memory as a unidimensional array using the row-major order (aka lexicographic order; aka row-by-row):</p>
<p ><b>0 1 2 3 4 0 1 2 3 4</b> 0 0 0 0 0 1 1 1 1 1 10 11 12 13 14 15 16 17 18 19 1...</p>
<ul>
<li>The MLX42 GUI image object has its own coordinate system where the XY origin is at the top-left corner.<ul>
<li>X values grow going to the left.</li>
<li>Y values grow going downward.</li>
<li>(The program deals with the coordinate system mismatch in some of the several transformations when rendering).</li>
</ul>
</li>
<li>Vertex color is supported for .fdf map files if an altitude value is followed by ",0xhhhhhh" where h are hexadecimal digits representing RGB values. This is transformed to the 8 bits per channel RGBA color model format supported by MLX42 library as 0xhhhhhhFF (channel alpha value does not come from the .fdf file and is always considered 0xFF).</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Data structures</h2>
<ul>
<li>Array of two matrices resulting from loading the .fdf map file. The first matrix contains altitude values (Z axis) while the second matrix contains color values (255 if map has no color info). The column and row in each matrix represents the X, Y coordinates.</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Program's internal working</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Core functions callings</h2>
<ul>
<li>main() function does the following:<ul>
<li>Checks validity of arguments.</li>
<li>Creates the fdf data structure which serves as an entry point to every other data.</li>
<li>Loads the .fdf file data into an array of two matrices (one for height or Z values and the other one for color values) by calling <a class="el" href="lin__alg__bonus_8h.html#a704fad2e4dbc239b4bf343a2265e52bc" title="ft_mx_load_file – TODO.">ft_mx_load_file()</a>.</li>
<li>Calls <a class="el" href="window__bonus_8h.html#aafea7a88379582e1a5f8902133a619a5" title="fdf_start_gui – TODO.">fdf_start_gui()</a> which does the following:<ul>
<li><a class="el" href="window__bonus_8h.html#aafea7a88379582e1a5f8902133a619a5" title="fdf_start_gui – TODO.">fdf_start_gui()</a> registers the hooks:<ul>
<li>mlx_resize_hook() -&gt; <a class="el" href="window__bonus_8h.html#ad387c47ba3be5c01a21d7a5b8ab501be" title="fdf_resizehook – TODO.">fdf_resizehook()</a>.</li>
<li>mlx_key_hook() -&gt; <a class="el" href="window__bonus_8h.html#a213a8c91866bd9eca03a0a69e9c848b8" title="fdf_keyhook – TODO.">fdf_keyhook()</a>.</li>
<li>mlx_close_hook() -&gt; <a class="el" href="window__bonus_8h.html#a6f2d9dae393f97b927c04ee9d91c1666" title="fdf_closehook – TODO.">fdf_closehook()</a>.</li>
<li>mlx_loop_hook() -&gt; <a class="el" href="window__bonus_8h.html#a19dd662cab8c18a3d4ebffe894708354" title="fdf_generichook – TODO.">fdf_generichook()</a>.</li>
</ul>
</li>
<li>Creates the GUI: window, image, places the image on the window.</li>
<li>Then waits in the mlx_loop(). At this point (and until after the window is closed or the ESCAPE key is pressed), only the hooks functions are called to act as a result of the GUI events.<ul>
<li>When MLX loop breaks, <a class="el" href="window__bonus_8h.html#aafea7a88379582e1a5f8902133a619a5" title="fdf_start_gui – TODO.">fdf_start_gui()</a> finishes the MLX clean up by calling mlx_terminate(). The MLX clean up process starts in the <a class="el" href="window__bonus_8h.html#a6f2d9dae393f97b927c04ee9d91c1666" title="fdf_closehook – TODO.">fdf_closehook()</a> when it calls the <a class="el" href="fdf__features__bonus_8h.html#a768ca29c70716780625ec8c5adb6c3a2" title="fdf_exit_program – TODO.">fdf_exit_program()</a> which calls the MLX functions mlx_delete_image() and mlx_close_window(). <br  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p ><em>[...... while <a class="el" href="window__bonus_8h.html#aafea7a88379582e1a5f8902133a619a5" title="fdf_start_gui – TODO.">fdf_start_gui()</a> is blocked in the MLX loop ......]</em></p><ul>
<li>Asinchronously, <a class="el" href="window__bonus_8h.html#a19dd662cab8c18a3d4ebffe894708354" title="fdf_generichook – TODO.">fdf_generichook()</a> is called on every MLX loop. This function does the following:<ul>
<li>Checks if the keys to translate/rotate/scale are pressed down. If any, this function updates the required transformation data through fdf structure object member and sets a t_render_request level at the fdf structure if a render is required as a result of the keys events.<ul>
<li><em>NOTE: Other hooks such as <a class="el" href="window__bonus_8h.html#ad387c47ba3be5c01a21d7a5b8ab501be" title="fdf_resizehook – TODO.">fdf_resizehook()</a> and <a class="el" href="window__bonus_8h.html#a213a8c91866bd9eca03a0a69e9c848b8" title="fdf_keyhook – TODO.">fdf_keyhook()</a> also can independently change transformation data and set a render request level.</em></li>
</ul>
</li>
<li>Calls <a class="el" href="drawing__bonus_8h.html#ae4d3890bd1636469ac309d3900d92ad3" title="fdf_render – TODO.">fdf_render()</a> every loop. <em>NOTE: <a class="el" href="window__bonus_8h.html#a19dd662cab8c18a3d4ebffe894708354" title="fdf_generichook – TODO.">fdf_generichook()</a> is the only caller of <a class="el" href="drawing__bonus_8h.html#ae4d3890bd1636469ac309d3900d92ad3" title="fdf_render – TODO.">fdf_render()</a>.</em> This function is the last one that is called with fdf as an argument, from now on, every function is called passing the fdf member object. <a class="el" href="drawing__bonus_8h.html#ae4d3890bd1636469ac309d3900d92ad3" title="fdf_render – TODO.">fdf_render()</a> function does the following:<ul>
<li>Checks the fdf t_render_request member fdf-&gt;render_request.</li>
<li>According to the render request level, <a class="el" href="drawing__bonus_8h.html#ae4d3890bd1636469ac309d3900d92ad3" title="fdf_render – TODO.">fdf_render()</a> successively calls the following function BUT starting with the one that correspond to the request level. In this way, only those stages of the rendering process that need to be recalculated as per the request level are performed. The functions that perform each stage of the rendering process are (in the logical order of precedence) the following:<ul>
<li><a class="el" href="tesselator__bonus_8h.html#ac7949ee6e508cb7d7d25233d727a88ed" title="fdf_tesselate_map – TODO.">fdf_tesselate_map()</a> when render_request &lt;= FROM_MODEL.<ul>
<li>Read "Rendering process" section for details.</li>
</ul>
</li>
<li>fdf_setup_world() when render_request &lt;= FROM_WORLD.<ul>
<li>Read "Rendering process" section for details.</li>
</ul>
</li>
<li>fdf_setup_camera() when render_request &lt;= FROM_CAMERA.<ul>
<li>Read "Rendering process" section for details.</li>
</ul>
</li>
<li>fdf_setup_screen() when render_request &lt;= FROM_SCREEN.<ul>
<li>Read "Rendering process" section for details.</li>
</ul>
</li>
<li>fdf_setup_image() when render_request &lt;= FROM_IMAGE.<ul>
<li>Read "Rendering process" section for details.</li>
</ul>
</li>
</ul>
</li>
<li>Finally, <a class="el" href="drawing__bonus_8h.html#ae4d3890bd1636469ac309d3900d92ad3" title="fdf_render – TODO.">fdf_render()</a> resets the render request level to NO_RENDER and returns to <a class="el" href="window__bonus_8h.html#a19dd662cab8c18a3d4ebffe894708354" title="fdf_generichook – TODO.">fdf_generichook()</a>. <br  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >The next section details what the rendering process functions (<a class="el" href="tesselator__bonus_8h.html#ac7949ee6e508cb7d7d25233d727a88ed" title="fdf_tesselate_map – TODO.">fdf_tesselate_map()</a>, fdf_setup_world(), fdf_setup_camera(), fdf_setup_screen(), and fdf_setup_image()) do at each stage of the rendering process.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Rendering process</h2>
<p >The rendering process entry point is the <a class="el" href="drawing__bonus_8h.html#ae4d3890bd1636469ac309d3900d92ad3" title="fdf_render – TODO.">fdf_render()</a> function, called from the GUI loop hook <a class="el" href="window__bonus_8h.html#a19dd662cab8c18a3d4ebffe894708354" title="fdf_generichook – TODO.">fdf_generichook()</a>.</p>
<p >The rendering process has several stages, let's call them transformations, which must be processed in this order, starting at the first stage that needs to be re-calculated. The selection of the first stage is determined by the render request level of fdf struct for each loop.</p>
<table class="doxtable">
<tr>
<th>Transformation </th><th>Details </th><th>Render level request </th><th>Associated function  </th></tr>
<tr>
<td><em>file to array of altitude and color matrices that represents the map info</em> </td><td><em>Not an actual part of the rendering process</em> </td><td><em>doesn't apply</em> </td><td><a class="el" href="lin__alg__bonus_8h.html#a704fad2e4dbc239b4bf343a2265e52bc" title="ft_mx_load_file – TODO.">ft_mx_load_file()</a>  </td></tr>
<tr>
<td>Map to 3D model </td><td>Either planar, spherical or cylindrical projection </td><td>&lt;= FROM_MODEL </td><td><a class="el" href="tesselator__bonus_8h.html#ac7949ee6e508cb7d7d25233d727a88ed" title="fdf_tesselate_map – TODO.">fdf_tesselate_map()</a>  </td></tr>
<tr>
<td>3D model to world </td><td></td><td>&lt;= FROM_WORLD </td><td>fdf_setup_world()  </td></tr>
<tr>
<td>World to camera </td><td></td><td>&lt;= FROM_CAMERA </td><td>fdf_setup_camera()  </td></tr>
<tr>
<td>Camera to screen </td><td></td><td>&lt;= FROM_SCREEN </td><td>fdf_setup_screen()  </td></tr>
<tr>
<td>Screen to image </td><td></td><td>&lt;= FROM_IMAGE </td><td>fdf_setup_image()  </td></tr>
<tr>
<td>Nothing to perform </td><td></td><td>== NO_RENDER </td><td>return  </td></tr>
</table>
<p >Not every rendering needs to go through all of these transformations, but just need to start at one of them and perform the rest. The level from which to start has to do with the requested actions: <br  />
</p><ul>
<li><em>[Should the map change, it has to start with file-to-map level]</em></li>
<li>Should the projection type change, it has to start with map-to-model level.</li>
<li>TODO</li>
</ul>
<h3><a class="anchor" id="autotoc_md11"></a>
Loading the .fdf file</h3>
<p >This is the process in which the .fdf file is parsed to create an array of two matrices. Both matrices are of the same size, that is, rows and columns positions representing the actual spatial 2D (XY plane) position of each sample.</p>
<p >Each sample will be then transformed into a 3D vertex in the tesselation stage.</p>
<p >There are two matrices because we need to storage two values for each point: the altitude value (the Z component) and the color value. <br  />
 The function <a class="el" href="lin__alg__bonus_8h.html#a704fad2e4dbc239b4bf343a2265e52bc" title="ft_mx_load_file – TODO.">ft_mx_load_file()</a> performs this stage, taking as argument the filename for the .fdf map and the expected character separating the sample information from the next sample information. The <a class="el" href="lin__alg__bonus_8h.html#a704fad2e4dbc239b4bf343a2265e52bc" title="ft_mx_load_file – TODO.">ft_mx_load_file()</a> function returns the array of the two matrices which will end up as the map_mx member of the object struct that is the object member of the fdf struct.</p>
<p >A .fdf file may or may not have sample color information. The color information is expected as a ',0xhhhhhh' string inmediately following each altitude value. If no color information is found, <a class="el" href="lin__alg__bonus_8h.html#a704fad2e4dbc239b4bf343a2265e52bc" title="ft_mx_load_file – TODO.">ft_mx_load_file()</a> initializes the color matrix with FFFFFF for each sample. <br  />
</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Tesselation: samples map to 3D model (where samples become vertices)</h3>
<p >This is the stage where: (1) the samples obtained from loading the .fdf file (2D position at XY plane + altitude) are used to create actual 3D XYZ points in space, this is dependent upon the type of projection: planar, spherical, or cylindrical; (2) for each of the samples (spatial-info-wise) a relationship is stablished with its neighboring samples in the matrix, this relationship is represented in an edge array and is the base for eventually drawing lines that connect each vertex only to its orthogonal neighbor vertices (or, in bonus version, also to its non-orthogonal neighbors that makes spatial sense; or to every neighbor). Each edge also contains the numeric value for the color of the start and end vertex.</p>
<p >In (1) one of this three functions: <a class="el" href="tesselator__bonus_8h.html#acbb6fba0e702d7154719db63c561c1a9" title="fdf_get_vertex_mx – Converts an altitude map matrix and color map matrix to a planar vertex matrix.">fdf_get_vertex_mx()</a>, <a class="el" href="tesselator__bonus_8h.html#a26e7cbf4b07d1bda7f5148ba6ba07da8" title="fdf_get_vertex_mx_sph – Converts an altitude map matrix and color map matrix to a spherical vertex ma...">fdf_get_vertex_mx_sph()</a>, or <a class="el" href="tesselator__bonus_8h.html#a69ef7e4b513e400f2d8d9c5671bddd33" title="fdf_get_vertex_mx_cyl – Converts an altitude map matrix and color map matrix to a cylindrical vertex ...">fdf_get_vertex_mx_cyl()</a> is used to create a matrix in which each column ?????? is a XYZW 3D point in space (a vertex). This matrix will become the model_mx member of the object, which is the object member of fdf.</p>
<p >In (2) the <a class="el" href="tesselator__bonus_8h.html#abd20646d0590ef38621345e51a8a152f" title="fdf_get_edge – TODO.">fdf_get_edge()</a> creates an array of edges, an edge is a struct type that has four key members: start and end, and start_color and end_color. The start and end members represent the index in the vertex matrix of the starting vertex of the edge and the end vertex of the edge. <br  />
 The start_color and end_color members contain the uint32_t value of the color of the start and end vertex. Clearly, each edge (if not hidden) will become a line on the image. <em>The call to <a class="el" href="tesselator__bonus_8h.html#abd20646d0590ef38621345e51a8a152f" title="fdf_get_edge – TODO.">fdf_get_edge()</a> is performed only once, when the model_mx member of the object is NULL, since the edge information (what point connects to another point and what colors should be used) will be the same for any tesselation projection type.</em></p>
<p >Both the vertex matrix column index (1) and the start/end members in the edges array indices (3) refer to the information of the same 3D vertex.</p>
<p >The next stages of the rendering process after tesselating the map consists of several succesive transformations from the vertex matrix for a stage to obtain the vertex matrix of the next stage. This vertex matrices are called spaces. These transformations to "get" the object to one space to the next, consist of succesively multiplying the previous vertex matrix (that represents the same points but in a particular space: the 3D object now placed in the world; the 3D object in the world but now from the point of view from the camera; or the 2D projection of the later to the screen) by different transformation matrices (to rotate, translate, scale, project) to generate the new vertex matrix for the next space.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
3D model space to world space transformation</h3>
<p >TODO</p>
<h3><a class="anchor" id="autotoc_md14"></a>
World space transformation to camera space transformation</h3>
<p >TODO</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Camera space to screen space transformation</h3>
<p >TODO</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Screen space to image space transformation</h3>
<p >In this stage, the vertex matrix representing the screen space is used to, finally, draw all the lines (edges) on the image. This job is ultimately perform by the <a class="el" href="drawing__bonus_8h.html#acce69e27bd09a9740edf8d7743539f76" title="ft_draw_edges – TODO.">fdf_drw_edges()</a> function.</p>
<p >The <a class="el" href="drawing__bonus_8h.html#acce69e27bd09a9740edf8d7743539f76" title="ft_draw_edges – TODO.">fdf_drw_edges()</a> function takes the object and the image element of the GUI and uses its auxiliary functions to draw each edge as a line onto the image.</p>
<h4><a class="anchor" id="autotoc_md17"></a>
Inner working of fdf_drw_edges() function</h4>
<p >This function loops through the edges array skipping the edges flagged as hidden and for each non-skipped edge:</p><ul>
<li>A line struct is created using <a class="el" href="drawing__bonus_8h.html#aa79c0a4455df834d963b4949106a75b8" title="fdf_create_line – Creates a 2D line from an edge of an object.">fdf_create_line()</a> function with the arguments: X value of the edge starting vertex; Y value of the edge starting vertex; X value of the edge end vertex; Y value of the edge end vertex.</li>
<li>TODO fdf_set_line_color_info() TODO !!!!!!!!!!!!!!</li>
<li>Finally, the <a class="el" href="drawing__bonus_8h.html#acce69e27bd09a9740edf8d7743539f76" title="ft_draw_edges – TODO.">fdf_drw_edges()</a> calls the fdf_draw_line() which actually draws the line.</li>
</ul>
<p >The <a class="el" href="drawing__bonus_8h.html#acce69e27bd09a9740edf8d7743539f76" title="ft_draw_edges – TODO.">fdf_drw_edges()</a> auxiliary functions inner workings are detailed in the following sections.</p>
<p ><em>NOTE: Bonus version edge skipping process in <a class="el" href="drawing__bonus_8h.html#acce69e27bd09a9740edf8d7743539f76" title="ft_draw_edges – TODO.">fdf_drw_edges()</a> is more or less strict depending on the user's selection to draw or not valid non-orthogonal edges or every non-orthogonal edges).</em></p>
<h5>Inner working of <a class="el" href="drawing__bonus_8h.html#aa79c0a4455df834d963b4949106a75b8" title="fdf_create_line – Creates a 2D line from an edge of an object.">fdf_create_line()</a> function</h5>
<p >TODO</p>
<h5>Inner working of fdf_set_line_color_info() function</h5>
<p >TODO</p>
<h5>Inner working of fdf_draw_line() function</h5>
<p >TODO </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
